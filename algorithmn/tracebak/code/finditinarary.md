题目描述：
![image](/algorithmn/tracebak/image/image13.png)  
解题过程：  
欧拉回路，欧拉通路，欧拉图，半欧拉图有向图和无向图的欧拉回路欧拉通路存在条件欧拉图半欧拉图存在条件，笑死，一个不会  
最大字典序，哈希表存储字符串到优先队列的映射关系，笑死又是一个不会  
题解强无敌只能说，真是太好理解了，若存在出度则选择字典序最大的路径然后删除该条路径进入下一个节点的查找，知道找到死胡同的时候才把当前节点加入栈中，则加入栈中的是可以寻找的路径上字典序最小的，最后翻转栈，OK  
move函数提高性能，学了一招  
- review：  
判断欧拉图和半欧拉图：  
- 对于无向图G，G是欧拉图当且仅当G是连通的且没有奇度顶点
- 对于无向图G，G是半欧拉图当且仅当G是连通的且G中恰有0个或2个奇度顶点
- 对于有向图G，G是欧拉图当且仅当G的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同
- 对于有向图G，G是半欧拉图当且仅当：
    - 如果将G中的所有有向边退化为无向边时，那么G的所有顶点属于同一个强连通分量
    - 最多只有一个顶点的出度和入度差为1
    - 最多只有一个顶点的入度与出度差为1
    - 所有其他顶点的入度和出度相同  
Hierholzer算法：  
1. 从起点出发，进行深度优先搜索
2. 每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边
3. 如果没有可以移动的路径，则将所在节点加入到栈中，并返回  
题目解法：  
1. 首先创建一个字符串到小顶堆存储字符串的优先队列（按照字符串的字典序）map，然后把机票数组上的节点和出度全部加入map中（这里是抽象化了节点和出度，总而言之就是对于一张机票，把出发点加入map中，指向一个优先队列，然后再把目的地加入到这个被指向的优先队列中）
2. 开始从起点进行深度优先搜索：如果被搜索的地方存在于map中且其指向的优先队列的大小大于0，则用temp接受优先队列的队头元素，并且优先队列pop出队头元素，然后对temp进行深度优先搜索。这个步骤是在while循环里完成的，只有当被搜索的地方指向的优先队列大小减到0时（从该地出发的机票全部都使用过了），才将该地加入到栈中
3. 翻转栈，就可以得到从指定地方出发且将所有机票都使用过一次的数组了  
这个算法还是比较抽象的：从指定地方出发，先按照字典序从小到大选择下一个地点，然后又从下一个地点开始按照字典序从小到大选择下一个地点，以此类推，直到某个地点不存在可以到达其他地点的边为止，那么这个地点必然是路径中的最后一个地点，于是把这个地点加入栈中。最后栈中的元素逐一弹出（即翻转），则可得到所求。  
第二次写的时候我还想着按顺序加入栈中，不用翻转也可以得到正确答案，结果差点创造出自己的算法哈哈哈。这样是不行的，假设第一条边直接是死胡同，那么加入的这条边根本不对，不是欧拉图也不是半欧拉图。  
代码：  
```cpp
class Solution {
private:
    unordered_map<string,priority_queue<string,vector<string>,greater<string>>> map;
    vector<string> stk;
public:
    void dfs(string curr) {
        while (map.count(curr) && map[curr].size() > 0) {
            string temp = map[curr].top();
            map[curr].pop();
            dfs(temp);
        }
        stk.push_back(curr);
    }
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        for (auto svec : tickets) {
            map[svec[0]].emplace(svec[1]);
        }
        dfs("JFK");
        reverse(stk.begin(),stk.end());
        return stk;
    }
};
```