题目描述： 
![image](/algorithmn/dynamic_programming/image/image39.png) 
这个题目离谱得要死感觉，我本来想用回溯处理的，但是想到要把数组里的数字删除然后再添加进来我就头疼，不知道该怎么办，看了题解，居然还有位运算，对啊，位运算来表示有没有选取这个数字，天才的。 
这个题目实际上是一道动态规划的题目，主要的思想是用dp[i]来表示状态i的情况下能得到的最大分数和，而状态i实际上是一个二进制数，而且这个二进制数中1的个数是偶数，因为奇数没有意义—不符合题目要求。于是可以自底向上地求解，如果nums有m位，那么最终dp[1 << m - 1]即为所求。 
在自底向上求解之前，需要计算每两个数之间的最大公约数并且存放在一个数组中，这样可以减少每次需要计算最大公约数的麻烦。 
从状态1开始循环直至状态1 << m - 1，如果某个状态的1个数为奇数则跳过（这里要用到一个api  `__builtin_popcount()`）。为偶数则进行状态转移：对nums中的所有数进行循环，如果某个数字处于可以被删除的状态（比方说这个数的下标是i，则状态右移i位之后如果和1相与仍为正数则说明这个数可以被删除），则从这个数字的下一个数字开始进行循环，找到下一个可以被删除的数字，当找到两个可以被删除的数字之后，依据自底向上的思路，在计算这个状态的得分最大和之前已经有一些状态的得分最大和被计算出来了，因此可以用这个状态和这两个要被删除的数字的状态进行异或，表示状态转移，若此时状态的1的个数为t，则正在进行的是第t / 2次计算，所以要加上 (t / 2) * gcd(x,y)。在这样的循环中不断地取最大值，等到循环退出之后即可得到这个状态的得分最大和，依次计算即可得到答案。  
代码：  
```cpp
class Solution {
public:
    int maxScore(vector<int>& nums) {
        int m = nums.size();
        vector<vector<int>> gcd_tmp(m,vector<int> (m));
        for (int i = 0; i < m; i++) {
            for (int j = i + 1; j < m; j++) {
                gcd_tmp[i][j] = gcd(nums[i],nums[j]);
            }
        }
        int all = 1 << m;
        vector<int> dp(all);
        for (int s = 1; s < all; s++) {
            int t = __builtin_popcount(s);
            if (t & 1) continue;
            else {
                for (int i = 0; i < m; i++) {
                    if ((s >> i) & 1) {
                        for (int j = i + 1; j < m; j++) {
                            if ((s >> j) & 1) {
                                dp[s] = max(dp[s],(dp[s ^ (1 << i) ^ (1 << j)] + (t / 2) * gcd_tmp[i][j]));
                            }
                        }
                    }
                }
            }
        }
        return dp[all-1];
    }
};
```