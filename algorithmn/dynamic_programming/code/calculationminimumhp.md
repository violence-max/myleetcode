题目描述：  
![image](/algorithmn/dynamic_programming/image/image47.png)  
解决过程：
动态规划的经典题目，我用记忆化搜索加回溯操作超时了，回溯基本思路如下：  
从左上角开始出发，初始时最低血量为1，剩余血量为1，如果当前房间健康点数为负数，则比较剩余血量和健康点数绝对值，若前者大，则无需改变最低血量，设置剩余血量为前者与后者的差值，若后者大于等于前者，则需要补充后者与前者的差值再加1，加1是为了保证到达这个房间至少有一滴血，设置剩余血量为1；若健康点数为整数，则剩余血量加上健康点数即可。使用记忆数组存储每个房间的最低血量和剩余血量，如果已经到达过该房间并且之前的血量大于等于当前血量并且之前的剩余血量大于等于当前的剩余血量，则继续探索没有价值，因此直接退出  
看了题解，从公主走到骑士，很有趣。假设到达了公主的房间之后只有最低血量1，那么从公主的房间开始，每次只关注右边的房间和下面的房间，可以直接从这两个房间的最低血量的最小值减去当前房间的健康点数之后的值与1取最大值对当前房间的最低血量进行赋值，不是很好发现，但是很有趣  
代码：  
```cpp
class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        int m  = dungeon.size() , n = dungeon[0].size();
        vector<int> dp (n+1,INT_MAX);
        dp[n] = 1; dp[n-1] = 1;
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                int minn = min(dp[j+1],dp[j]);
                if (j == n - 1 && dp[n] == 1) dp[n] = INT_MAX;
                dp[j] = max(minn - dungeon[i][j],1);
            }
        }
        return dp[0];
    }
};
```