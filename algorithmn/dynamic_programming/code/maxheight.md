题目描述：  
![image](/algorithmn/dynamic_programming/image/image36.png)  
解决过程：  
又是一看就废，实在是有难度啊这种题目。看了题解，发现面对这种类似于比大小的取最值的题目一定有的套路是排序+动态规划，但是动态规划的定义还是要好好练练。像这道题，动态规划的定义我感觉就挺刁钻的：dp[i]表示以第i块长方体作为最后一块长方体能得到的最大高度。然而，本来我以为这个”最后一块长方体“指的是最顶部的长方体，没有想到是最后一块长方体。包括它的递推方程，要么是本身的高度，要么是能够摆在它之上的长方体的高度加上本身的高度（这里这样表述只是为了求一个最大值而已）所以在计算一个长方体作为最后一块长方体时能得到的最大高度时，一定要把能摆在其之上的长方体对应的最大高度计算出来，这就决定了循环的顺序。  
这道题还有一个比较有趣的地方在于其数学的证明。因为一个长方体能够摆在另外一个长方体之上一定要满足长宽高各自小于等于的关系，那么通过贪心的思想我们会认为摆放每个长方体时应该把最长的那一条边作为高，这样我们肯定能得到最大高度（事实上这里应该也需要严格的数学证明，因为我总感觉有可能有那么几个长方体不需要摆放时取最长的那一条边作为高，而是为了让更多边长更加高的长方体摆在它之上来取到最大值）好吧，我自己忘记了，其实这里已经证明了哈哈哈，主要的证明过程就是如果一个长方体摆放在另外一个长方体之上那么以这两个长方体最长的边作为高仍然能满足摆放的关系，这才能取到最大值。证明过程主要用到了反证法，题解写得很拉，我脑子里记得就好了（记不得现推也可以）  
代码：  
```cpp
class Solution {
public:
    int maxHeight(vector<vector<int>>& cuboids) {
        int n = cuboids.size();
        for (auto &c : cuboids) {
            sort(c.begin(),c.end());
        }
        sort(cuboids.begin(),cuboids.end(),[](const vector<int> &a,const vector<int> &b) {
            return a[0] + a[1] + a[2] < b[0] + b[1] + b[2];
        });
        vector<int> dp(n);
        int ans = 0;
        for(int i = 0; i < n; i++) {
            dp[i] = cuboids[i][2];
            for (int j = 0; j < i; j++) {
                if (cuboids[j][0] <= cuboids[i][0] &&
                    cuboids[j][1] <= cuboids[i][1] &&
                    cuboids[j][2] <= cuboids[i][2]
                ) {
                    dp[i] = max(dp[i],dp[j]+cuboids[i][2]);
                }
            }
            ans = max(ans,dp[i]);
        }
        return ans;
    }
};
```