题目描述：  
![image](/basical/gragh/image/image3.png)  
要讲清楚这个题实在是有点难度啊。  
首先来看一下题意，我在理解题意上还是花了一些时间的（20分钟左右，还是看题解才理解的）。题目的意思是密码是n位数，而密码的每一位是0到k-1中的任何一位都可能，所以输入的密码（不论是多少位只读取最后n位，模仿实际，密码箱是随时读取最后n位的，所以输入的过程类似于一个滑动窗口，不停地读取n位数据，直到匹配）必须包含所有的0到k-1位数的组合。因此，密码总共有k^n种可能。  
算法：  
由题意，这道题实际上是一道求解欧拉回路的问题，但是抽象出这个欧拉回路并不简单。  
类似于一个状态机，其实在滑动窗口的过程中每次都在低位新增加一位，在高位减少一位，直到这个滑动窗口把所有密码的可能都遍历过一次为止，遍历过的数字组成的字符串构成一个答案，而这很符合状态机的工作原理—读取一个字符并且转移到下一个状态，实际上滑动窗口读入一个字符的过程就是一个状态转移的过程。  
因此可以对数字进行抽象：我们假设由k^(n-1)个顶点，顶点的编号从0开始计数。每个顶点有k个出度和k个入度，代表着这个顶点可以从另外k个顶点到达并且可以到达另外k个顶点。例如：n = 3，k = 2，则顶点的编号分别为0，1，2，3，而对于顶点0，其读入一个0，可以到达本身，读入一个1可以到达1。实际上， 顶点的编号和顶点本身可以用更加抽象的表达：以上这种情况可以把顶点的编号看作是：00，01，10，11，这像什么？是不是像二进制从0开始逐步加1？实际上这就是的。因为顶点的个数有k^(n-1)个，而观察顶点编号的产生情况可以发现，从0开始，末位逐个加1，加了k次之后开始进行一次进位，直到n-1位全部都是数字k-1为止将所有编号列举完毕。因此，编号实际上可以用k进制进行表示，从0开始逐步加1。  
那么我们就可以从顶点0开始进行深度遍历，我学到的有两种方法：hierholzer算法或者贪心算法。前者不在赘述，后者的思路是每次的选择从高位到低位，即每次从k-1开始进行选择并且状态转移，这样子最终可以回到顶点0的位置并且可以避免提前回到顶点0的情况（虽然提前回到顶点0也没什么不好的，就是时间耗费的多了一点，因为要处理之前已经遍历过的顶点）。  
经过以上的描述，其实题目的解法已经很通透了。  
答案就是一个n-1加上k^n位数字的字符串。n-1来自于我们需要从顶点0出发，k^n来自于我们总共需要走k^n条边才能回到顶点0（我使用贪心算法，如果使用hierholzer算法应该描述成需要走过k^n条边）。  
噢对了，其实我对于为什么有k^n条边还花了一点时间去理解，这里简单描述一下，其实就是总共有k^(n-1)个顶点，每个顶点总共有k个入度和k个出度因此总度数为k^(n-1) * 2 * k，总度数除以2就是边的数目。  
因此，从顶点0开始，逐渐地从高位开始进行顶点之间地状态转移就可以得到答案了。  
贪心算法：  
1. 初始化顶点数组nums，其大小为k^(n-1)，数值为k-1（因为要从高位开始选择）
2. 初始化答案字符串s，其长度为n-1+k^n，每一位都为字符0
3. 答案字符串前n-1位为0不变，表示着我们从状态0开始进行转移。使用指针i指向n-1，表示着我们要开始进行字符的读入进行窗口的滑动以及状态的转移，起初节点node赋值为0。直到指针i移动到s的末尾才停止循环，每次指针加1，可以使用while循环或者for循环等
4. 每次循环发生一次状态转移：将s的第i位上的数据更改为nums[node]的数据，表示我们从节点node上的高位开始选择下一个我们要到达的节点，当选择结束后nums[node]自减1表示从高位选择到低位。  
    接下来是最重要也是稍微有点难理解的一点—节点之间的转移：  
    经过以上的描述，其实我们已经知道了节点的编号是按照k进制从0开始逐步加1进行变化的，但是我在发现这一点上就花了比较久的时间。知道了这个之后节点之间的转移规则就非常容易理解了。  
    每个节点总共有n-1位，一开始是节点0，因此一开始的节点应该是n-1个0。而当我们在第i位选择了高位（从k-1开始）以后，我们应该发生节点之间的转移，即从n-1个0转移到末位为k-1，高n-2位为0这么一个节点。结合每个节点是一个k进制数。所以只需要先将node乘以k，即先减末位腾出一个0的位置，然后减去最高位（因为窗口的滑动导致最高位丢失），最高位为当前指针之前的n-1位数据乘以k^(n-1)（node先乘以k之后node共有n位数据），然后再加上末位的值，即nums[node]+1（这里加1是因为之气那nums[node]进行了自减1）  
5.  当指针移动到s的末尾时，s就是一个可以使用的密码了
hierholzer算法：  
1. 设置highest为10^(n-1)，定义一个转载int型数据的哈希集合set，用ans表示答案字符串，k记录参数k值
2. 从节点0开始进行深度遍历：用for循环，因为每个节点有k个出度，因此可以用一个值（i）从0开始，直到k-1结束，共k次循环体，每次i加1，来模仿从节点node到达哪个节点。下一个节点的规则比较简单：当前的node乘以10之后加上i即可。不同于贪心算法的k进制，这里笼统地使用十进制进行约束。因为对于一个n-1位数而言，如果是十进制，那最大的情况不外乎就是k=10的时候有n-1个9，但是highest已经限定了为10^(n-1)，因此在得到每个节点之后，可以使用节点对highest进行取模得到下一个要遍历的节点（比如当处于节点99的时候输入一个9来实现自环，那么下一个节点的编号为999，对highest取模得到99，n=2）。如果下一个节点不存在于set中，则插入set中，然后遍历下一个节点。直到有一个节点无路可走时，说明到达了最后一个节点，此时加入答案ans中，额，hierholzer老套路了，我保证下次不会再解释这个点了。
3. 最终得到的ans如果进行翻转然后在之前加上n-1个0就是答案了，当然，也可以直接在末尾加上n-1个0，一样的

代码：（贪心→hierholzer）

```cpp
class Solution {
public:
    string crackSafe(int n, int k) {
        int kn = pow(k,n),kn_1 = pow(k,n-1);
        vector<int> nums (kn_1,k-1);
        string ans (n-1+kn,'0');
        for (int i = n - 1,node = 0; i < ans.length(); ++i) {
            ans[i] = nums[node]-- + '0';
            node = node * k - (ans[i-(n-1)]-'0') * kn_1 + nums[node] + 1;
        }
        return ans;
    }
};
```
```cpp
class Solution {
private:
    unordered_set<int> set;
    int k;
    int highest;
    string ans;
public:
    void dfs(int node) {
        for (int x = 0; x < k; x++) {
            int next = node * 10 + x;
            if (!set.count(next)) {
                set.insert(next);
                dfs(next % highest);
                ans += x + '0';
            }
        }
    }
    
    string crackSafe(int n, int k) {
        highest = pow(10,n-1);
        this->k = k;
        dfs(0);
        ans += string(n-1,'0');
        return ans;
    }
};
```